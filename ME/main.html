<!DOCTYPE html>

<html>

<head>
    <title>Example 01.02 - First Scene</title>
    <script type="text/javascript" src="../libs/three.js"></script>
    <script type="text/javascript" src="../libs/stats.js"></script>
    <script type="text/javascript" src="../libs/dat.gui.js"></script>
    <script type="text/javascript" src="../libs/OrbitControls.js"></script>
    <script type="text/javascript" src="../libs/Projector.js"></script>
    <style>
        body {
            /* set margin to 0 and overflow to hidden, to go fullscreen */
            margin: 0;
            overflow: hidden;
        }
        #button1{
            position:fixed;
            background-color:rgb(50,50,50);
            cursor:pointer;
            color:white;
            width:100px;
            height:30px;
            padding: 5px;
            right:5px;
            text-align:center;
            top:5px;
        }
    </style>
</head>
<body>
<input type="file" id ="button1" onclick="uploadtexture(event)"/>
<div id="Stats-output">
</div>
<!-- Div which will hold the Output -->
<div id="WebGL-output">
</div>
<!-- Javascript code that runs our Three.js examples -->
<script type="text/javascript">

    // once everything is loaded, we run our Three.js stuff.
    function init() {

        var stats = initStats();

        // create a scene, that will hold all our elements such as objects, cameras and lights.
        var scene = new THREE.Scene();

        // create a camera, which defines where we're looking at.
        var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 10000);

        // create a render and set the size
        var renderer = new THREE.WebGLRenderer();
        renderer.setClearColorHex();
        renderer.setClearColor(new THREE.Color(0xeeeeee));
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMapEnabled = true;

        var orbitControls = new THREE.OrbitControls(camera);
        orbitControls.autoRotate = false;
        var clock = new THREE.Clock();

        var projector = new THREE.Projector();
        document.addEventListener('mousedown', onDocumentMouseDown, false);
        document.addEventListener('mousemove', onDocumentMouseMove, false);

        // create the ground plane
        var planeGeometry = new THREE.PlaneGeometry(500, 500);
        var planeMaterial = new THREE.MeshBasicMaterial({color: 0xaaaaaa});
        var plane = new THREE.Mesh(planeGeometry, planeMaterial);
        plane.receiveShadow = true;

        var planeGeometry2 = new THREE.PlaneGeometry(150, 100);
        var planeMaterial2 = new THREE.MeshBasicMaterial({color: 0xdddddd});
        var plane2 = new THREE.Mesh(planeGeometry2, planeMaterial2);

        var planeGeometry2_1 = new THREE.PlaneGeometry(150, 100);
        var planeMaterial2_1 = new THREE.MeshBasicMaterial({color: 0xdddddd});
        var plane2_1 = new THREE.Mesh(planeGeometry2_1, planeMaterial2_1);

        // rotate and position the plane
        plane.rotation.x = -0.5 * Math.PI;
        plane.position.x = 15;
        plane.position.y = 0;
        plane.position.z = 0;
        scene.add(plane);

        // rotate and position the plane
        plane2.rotation.x = -0.5* Math.PI;
        plane2.rotation.y = 0.5* Math.PI;
        plane2.position.x = 0;
        plane2.position.y = 100;
        plane2.position.z = 50;
        scene.add(plane2);
        plane2_1.rotation.x = -0.5* Math.PI;
        plane2_1.rotation.y = 0.5* Math.PI;
        plane2_1.position.x = 0;
        plane2_1.position.y = 100;
        plane2_1.position.z = -55;
        scene.add(plane2_1);
        
        var cplane3x = 0;
        var cplane3y = 0;
        var planey = 150;

        var light = new THREE.DirectionalLight();
        light.position.set(100, 30, 20);
        scene.add(light);

        function setPlanePosition(obj) {
            if(cplane3x<=5) {
                if(cplane3x % 2 == 0) {
                    if(cplane3y % 2 == 0 && cplane3x>=2) {
                       planey -= 45
                    }
                    obj.position.set(
                        0.5,
                        planey,
                        80
                    );
                } else {
                    obj.position.set(
                        0.5,
                        planey,
                        30
                    );
                }
            }
            else {
                if(cplane3x == 6) {planey=150; }
                if(cplane3x % 2 == 0) {
                    if(cplane3y % 2 == 0 && cplane3x>=7) {
                       planey -= 45
                    }
                    obj.position.set(
                        0.5,
                        planey,
                        -25
                    );
                } else {
                    obj.position.set(
                        0.5,
                        planey,
                        -75
                    );
                }
            }
            cplane3x+=1;
            obj.rotation.set(
                -0.5*Math.PI,
                0.5* Math.PI,
                0
            );
            obj.castShadow = true;
        }
        var a;
        var controls = new function() {
            this.numberOfObjects = scene.children.length;
            this.showRay = false;

            this.addPlaneMesh = function () {
                if (scene.children.length == 16){}
                else {
                    var pl ane3 = createMesh(new THREE.PlaneGeometry(35,30),"floor-wood.jpg");
                    plane3.material.needsUpdate = true;
                    setPlanePosition(plane3);
                    scene.add(plane3);
                    plane3.name = "plane3_" + scene.children.length;
                    this.numberOfObjects = scene.children.length;
                    console.log(plane3.name);
                    a=plane3;
                }
            };
            this.removePlane = function () {
                if (scene.children.length <=3){}
                else {
                    var allChildren = scene.children;
                    var lastObject = allChildren[allChildren.length -1];
                    if(lastObject instanceof THREE.Mesh) {
                        scene.remove(lastObject);
                        this.numberOfObjects = scene.children.length;
                    }
                    if(cplane3x>=1){ cplane3x-=1;};
                    if(cplane3x==6){ planey=60;};
                    if(cplane3x % 2 == 0 && cplane3x!=0 && cplane3x>=5) { planey += 45 };
                }   
            };
        }

        function createMesh(geom, imageFile) {
            var texture = THREE.ImageUtils.loadTexture("../assets/textures/general/" + imageFile);
            var mat = new THREE.MeshPhongMaterial();
            mat.map = texture;

            var mesh = new THREE.Mesh(geom, mat);
            return mesh;
        }
        


        // position and point the camera to the center of the scene
        camera.position.x = 600;
        camera.position.y = 100;
        camera.position.z = 0;
        camera.lookAt(scene.position);

        // add the output of the renderer to the html element
        document.getElementById("WebGL-output").appendChild(renderer.domElement);

        var gui = new dat.GUI();
        gui.add(controls, 'addPlaneMesh');
        gui.add(controls, 'removePlane');
        gui.add(controls, 'numberOfObjects').listen();
        gui.add(controls, 'showRay').onChange(function (e) {
            if (tube) scene.remove(tube)
        });

        // render the scene
        render();    

        function render() {
            stats.update();

            //sphere.rotation.y=step+=0.01;
            var delta = clock.getDelta();
            orbitControls.update(delta);

            // render using requestAnimationFrame
            requestAnimationFrame(render);
            renderer.render(scene, camera);
        }

        var projector = new THREE.Projector();
        var tube;

        function uploadtexture(event) {
            event.preventDefault();
            let fileObject = document.getElementById("input_file");
            let fileName = fileObject.files[0];
            let fr = new FileReader();
            fr.readAsText(fileName, "utf-8");

            fr.onload = () => {
                parseText(fr.result);
            }
        }
        function parseText(text) {
            console.log(text)
            // 여기서 파일 가공하면됨
        }
        
        function onDocumentMouseDown(event) {

            var vector = new THREE.Vector3(( event.clientX / window.innerWidth ) * 2 - 1, -( event.clientY / window.innerHeight ) * 2 + 1, 0.5);
            vector = vector.unproject(camera);

            var raycaster = new THREE.Raycaster(camera.position, vector.sub(camera.position).normalize());

            var intersects = raycaster.intersectObjects([plane]);
            
            if (intersects.length > 0) {

                console.log(intersects[0]);
                //intersects[0].object.material.transparent = true;
                //intersects[0].object.material.opacity = 0.1;
                //intersects[0].object.
                //uploadtexture(event);
            }
        }

        function onDocumentMouseMove(event) {
            if (controls.showRay) {
                var vector = new THREE.Vector3(( event.clientX / window.innerWidth ) * 2 - 1, -( event.clientY / window.innerHeight ) * 2 + 1, 0.5);
                vector = vector.unproject(camera);

                var raycaster = new THREE.Raycaster(camera.position, vector.sub(camera.position).normalize());
                var intersects = raycaster.intersectObjects([sphere, cylinder, cube]);

                if (intersects.length > 0) {

                    var points = [];
                    points.push(new THREE.Vector3(-30, 39.8, 30));
                    points.push(intersects[0].point);

                    var mat = new THREE.MeshBasicMaterial({color: 0xff0000, transparent: true, opacity: 0.6});
                    var tubeGeometry = new THREE.TubeGeometry(new THREE.SplineCurve3(points), 60, 0.001);

                    if (tube) scene.remove(tube);

                    if (controls.showRay) {
                        tube = new THREE.Mesh(tubeGeometry, mat);
                        scene.add(tube);
                    }
                }
            }
        }

        function initStats() {

            var stats = new Stats();
            stats.setMode(0); // 0: fps, 1: ms
            
            // Align top-left
            stats.domElement.style.position = 'absolute';
            stats.domElement.style.left = '0px';
            stats.domElement.style.top = '0px';

            //프레임 ui
            //document.getElementById("Stats-output").appendChild(stats.domElement);

            return stats;
        }
        
    }
    window.onload = init;

</script>
</body>
</html>